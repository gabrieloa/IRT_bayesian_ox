#include <set_theta.ox>

setparam(decl a, decl b, decl c, decl theta, decl taut, decl taua){

decl t1, t2;
decl st1, st2;
decl NumStud,i;

decl matriz,probb;

NumStud = sizer(theta);
probb=probn(aAtual*ThetaAtual-bAtual*ones(1,NumStud));
matriz=log(1-probb)+Resp.*(log(probb)-log(1-probb));

i=2;

for(k = 1; k <= 9000; ++k)	 
	{

	V= calcV(aAtual,bAtual,cAtual,ThetaAtual);										                   //criar
																									   
	Z=CondZ(aAtual,bAtual,cAtual,ThetaAtual,V,Resp);

	//atualizando a matriz com o log para o Metropolis-Hasting
	[matriz]=Matrizlog(aAtual,bAtual,ThetaAtual,matriz,t2,1,Resp);

	if(k==1){
	t2=zeros(NumItem,1);
	}
																																 
	ThetaAtual,t1=MetropolisTheta(aAtual,bAtual,ThetaAtual,Resp,Z,taut,matriz);																	 

	if(k>999){
	st1+=t1;}

	Theta[k][] = ThetaAtual[0:99] ;

	[matriz]=Matrizlog(aAtual,bAtual,ThetaAtual,matriz,t1,0,Resp);

	aAtual,bAtual,t2=MetropolisAB(aAtual,bAtual,ThetaAtual,Resp,Z,MeanAPrior,SigmaAPrior,MeanBPrior,SigmaBPrior,taua,taua,matriz);		  //criar

	if(k>999){
	st2+=t2;}
																																				 
	a[k][] = aAtual';
	b[k][] = bAtual';

	cAtual = CondC(Z, AlphaPrior, BetaPrior, NumStud, NumItem);

	c[k][] = cAtual';					

	if(k==i*1000-1){
	 st1=st1./1000;
	 st2=st2./1000;	 

	 println(sizer(vecindex(st1.>= 0.3 .&& st1.<=0.4)));
	 println(sizer(vecindex(st2.>= 0.3 .&& st2.<=0.4)));
	 
	savemat("st1.mat",st1,1);
	savemat("st2.mat",st2,1);
	
	taut = set_theta(st1,taut);
	st1=zeros(1,NumInd);

	i+=1;
	}
}
}